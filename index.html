<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>å¿ƒé›»å›³ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–å­¦ç¿’ãƒšãƒ¼ã‚¸ï¼ˆæ”¹è‰¯ç‰ˆï¼‰</title>
<meta name="description" content="ECG Trainer: 25 mm/sãƒ»10 mm/mV ã®å®Ÿå¯¸ã‚°ãƒªãƒƒãƒ‰ã§å¿ƒé›»å›³æ³¢å½¢ã‚’ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–ã«å­¦ã¹ã¾ã™ã€‚å¤šæ•°ã®ä¸æ•´è„ˆãƒ‘ã‚¿ãƒ¼ãƒ³ã€é€Ÿåº¦ãƒ»æ„Ÿåº¦èª¿æ•´ã€PNGä¿å­˜ã€ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰æ“ä½œã«å¯¾å¿œã€‚">
<meta name="theme-color" content="#0b1220" media="(prefers-color-scheme: dark)">
<meta name="theme-color" content="#ffffff" media="(prefers-color-scheme: light)">
<m    case 'torsades':{
      // Torsades de pointes: polymorphic VT with twisting QRS amplitude around the baseline
      // Use a wide QRS and modulate amplitude and axis over a multi-second envelope
      // Base waveform with wide QRS and modest repolarisation; amplify to emphasise polymorphic nature
  setSeg(0,320,580);
  const base = morphBasic(p,{pr:0,qrs:480,qt:580,pAmp:0.0,qAmp:-0.35,rAmp:1.4,sAmp:-0.55,tAmp:0.10});
      // Envelope varies slowly (~3 s) to produce waxing and waning amplitude
  const env = 0.55 + 0.45 * Math.sin(2 * Math.PI * ((t % 3500) / 3500));
  // Alternate polarity over ~7 s to simulate axis rotation
  const sign = Math.sign(Math.sin(2 * Math.PI * ((t % 7000) / 7000))) || 1;
      return base * env * sign;y="og:title" content="ECG Trainer â€“ å¿ƒé›»å›³ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–å­¦ç¿’">
<meta property="og:description" content="å®Ÿå¯¸ã‚°ãƒªãƒƒãƒ‰ã§æ»‘ã‚‰ã‹ãªæ³¢å½¢è¡¨ç¤ºã€‚å¤šæ•°ã®ãƒªã‚ºãƒ ã‚’åˆ‡æ›¿ãˆå­¦ç¿’ã§ãã¾ã™ã€‚">
<meta property="og:type" content="website">
<style>
  :root{
    --bg:#0b1220; --panel:#111a2b; --ink:#e6edf3; --muted:#98a2b3; --accent:#5eead4; --warn:#f97316;
    --grid-sm: rgba(255,255,255,0.06); --grid-lg: rgba(255,255,255,0.10);
    --btn-bg:#17243b; --btn-bd:#27406a; --btn-ink:var(--ink);
  }
  html[data-theme="light"]{
    /* ECGè¨˜éŒ²ç´™é¢¨ï¼ˆãƒ©ã‚¤ãƒˆãƒ†ãƒ¼ãƒï¼‰ */
    --bg:#ffffff; --panel:#ffffff; --ink:#0b1220; --muted:#475569; --accent:#0ea5e9; --warn:#ea580c;
    /* 1mmè–„ç·šã€5mmæ¿ƒç·šã€‚ãƒ”ãƒ³ã‚¯ç³»ã§è¦–èªæ€§ã‚’é«˜ã‚ã‚‹ */
    --grid-sm: rgba(234, 84, 98, 0.22);
    --grid-lg: rgba(234, 84, 98, 0.45);
    --btn-bg:#f8fafc; --btn-bd:#dbe3ea; --btn-ink:#0b1220;
  }
  /* èƒŒæ™¯ã¯ãƒ†ãƒ¼ãƒå¤‰æ•°ã«åˆã‚ã›ã‚‹ã€‚ãƒ€ãƒ¼ã‚¯æ™‚ã®ã¿ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’é‡ã­ã‚‹ */
  html,body{height:100%; margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; color:var(--ink); background:var(--bg);} 
  html:not([data-theme="light"]) body, html:not([data-theme="light"]) { background:linear-gradient(180deg,#0a0f1b 0%, #0e1526 40%, #111827 100%);} 
  .wrap{display:grid; grid-template-columns: 340px 1fr; gap:16px; height:100%}
  aside{background:var(--panel); border-right:1px solid #1f2b3f; padding:18px; overflow:auto}
  main{padding:18px; overflow:auto}
  h1{font-size:24px; margin:0 0 8px}
  h2{font-size:18px; margin:16px 0 8px}
  p{line-height:1.7}
  .card{background:rgba(255,255,255,0.03); border:1px solid #22304a; border-radius:14px; padding:14px; box-shadow:0 8px 30px rgba(0,0,0,.35)}
  .btn{background:var(--btn-bg); color:var(--btn-ink); border:1px solid var(--btn-bd); padding:8px 12px; border-radius:10px; cursor:pointer}
  .btn:focus-visible{outline:2px solid var(--accent); outline-offset:2px}
  .row{display:flex; gap:12px; align-items:center; flex-wrap:wrap}
  .row-between{justify-content:space-between}
  .align-end{align-items:end}
  .mt-8{margin-top:8px}
  .pill{display:inline-block; padding:4px 8px; border-radius:999px; background:#13223a; border:1px solid #20304f; font-size:12px; color:var(--muted)}
  .kbd{font-family: ui-monospace, SFMono-Regular, Menlo, monospace; padding:2px 6px; border:1px solid #2a3b5c; background:#101a2b; border-radius:6px; font-size:12px}
  #stage{position:relative; height:340px}
  /* Stack grid and waveform canvases */
  #stage canvas{position:absolute; left:0; top:0}
  canvas{display:block; width:100%; height:320px; border-radius:12px; border:none; background:var(--bg)}
  #gridCanvas{background:var(--bg); border:1px solid #253554;}
  #ecgCanvas{background:transparent;}
  /* caliper UI removed per user request */
  #speed{width:100%}
  .grid-note{color:var(--muted); font-size:12px}
  /* Rhythm explanation should look like normal body text */
  #rhythmInfo{ font-size:16px; color:var(--ink); font-weight:400; line-height:1.7 }
  .qrs-toggle{gap:6px}
  .prewrap{white-space:pre-wrap}
  .h2-tight{margin:0}
  .sr-only{position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); border:0}
  .toolbar{display:flex; gap:8px; align-items:center}
  .theme-toggle{background:transparent; border:1px solid var(--btn-bd); padding:6px 10px; border-radius:999px; transform: translateY(-4px)}
  .toolbar .test-link{ transform: translateY(-6px); }
  footer.site-footer{ margin-top:8px; padding:12px 16px; background:var(--panel); border-top:1px solid #1f2b3f; color:var(--muted); font-size:12px; text-align:center }
  @media (max-width: 900px){
    .wrap{grid-template-columns: 1fr}
    aside{border-right:none; border-bottom:1px solid #1f2b3f}
  }
</style>
</head>
<body>
<div class="wrap">
  <aside aria-label="ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒ‘ãƒãƒ«">
    <div class="row row-between">
  <h1>æ±æ´‹åŒ»ç™‚å°‚é–€å­¦æ ¡ã€€ECG Trainer</h1>
      <div class="toolbar">
        <button id="themeToggle" class="theme-toggle" title="ãƒ†ãƒ¼ãƒåˆ‡æ›¿ï¼ˆãƒ©ã‚¤ãƒˆ/ãƒ€ãƒ¼ã‚¯ï¼‰" aria-pressed="false">ğŸŒ™</button>
        <a class="btn test-link" href="test.html" title="ãƒ©ãƒ³ãƒ€ãƒ å¿ƒé›»å›³ã‚¯ã‚¤ã‚ºã¸">å¿ƒé›»å›³ãƒ†ã‚¹ãƒˆ</a>
      </div>
    </div>
    
    <div class="card">
      <h2 id="rhythmLegend">ãƒªã‚ºãƒ é¸æŠ</h2>
      <fieldset aria-labelledby="rhythmLegend">
        <legend class="sr-only">ãƒªã‚ºãƒ é¸æŠ</legend>
        <label><input type="radio" name="rhythm" value="sinus" checked> æ´èª¿å¾‹ï¼ˆ70/min å‰å¾Œï¼‰</label><br>
        <label><input type="radio" name="rhythm" value="af"> å¿ƒæˆ¿ç´°å‹•ï¼ˆAFï¼‰</label><br>
        <label><input type="radio" name="rhythm" value="afl"> å¿ƒæˆ¿ç²—å‹•ï¼ˆAFLï¼‰</label><br>
        <label><input type="radio" name="rhythm" value="psvt"> ç™ºä½œæ€§ä¸Šå®¤é »æ‹ï¼ˆPSVTï¼‰</label><br>
        <label><input type="radio" name="rhythm" value="vt"> å¿ƒå®¤é »æ‹ï¼ˆVTï¼‰</label><br>
        <label><input type="radio" name="rhythm" value="torsades"> ãƒˆãƒ«ã‚µãƒ¼ãƒ‰ãƒã‚¢ãƒ³ãƒ„ï¼ˆTdPï¼‰</label><br>
        <label><input type="radio" name="rhythm" value="vf"> å¿ƒå®¤ç´°å‹•ï¼ˆVFï¼‰</label><br>
        <label><input type="radio" name="rhythm" value="wpw"> WPWç—‡å€™ç¾¤ï¼ˆãƒ‡ãƒ«ã‚¿æ³¢ï¼‰</label><br>
        <label><input type="radio" name="rhythm" value="earlyRepol"> æ—©æœŸå†åˆ†æ¥µ</label><br>
        <label><input type="radio" name="rhythm" value="stElevation"> STä¸Šæ˜‡</label><br>
        <label><input type="radio" name="rhythm" value="stDepression"> STä½ä¸‹</label><br>
        <label><input type="radio" name="rhythm" value="hypoK"> ä½ã‚«ãƒªã‚¦ãƒ è¡€ç—‡</label><br>
        <label><input type="radio" name="rhythm" value="hyperK"> é«˜ã‚«ãƒªã‚¦ãƒ è¡€ç—‡</label><br>
        <label><input type="radio" name="rhythm" value="qtcLong"> QTå»¶é•·</label><br>
        <label><input type="radio" name="rhythm" value="qtcShort"> QTçŸ­ç¸®</label><br>
        <label><input type="radio" name="rhythm" value="rbbb"> å³è„šãƒ–ãƒ­ãƒƒã‚¯ï¼ˆRBBBï¼‰</label><br>
        <label><input type="radio" name="rhythm" value="lbbb"> å·¦è„šãƒ–ãƒ­ãƒƒã‚¯ï¼ˆLBBBï¼‰</label><br>
        <label><input type="radio" name="rhythm" value="avb1"> 1åº¦æˆ¿å®¤ãƒ–ãƒ­ãƒƒã‚¯</label><br>
        <label><input type="radio" name="rhythm" value="wenckebach"> 2åº¦æˆ¿å®¤ãƒ–ãƒ­ãƒƒã‚¯ï¼ˆWenckebachï¼‰</label><br>
        <label><input type="radio" name="rhythm" value="mobitz2"> 2åº¦æˆ¿å®¤ãƒ–ãƒ­ãƒƒã‚¯ï¼ˆMobitz IIï¼‰</label><br>
        <label><input type="radio" name="rhythm" value="chb"> å®Œå…¨æˆ¿å®¤ãƒ–ãƒ­ãƒƒã‚¯</label><br>
        <label><input type="radio" name="rhythm" value="pvc_single"> å˜ç™ºæ€§æœŸå¤–åç¸®</label><br>
        <label><input type="radio" name="rhythm" value="pvc_frequent"> å¤šç™ºæ€§æœŸå¤–åç¸®ï¼ˆbigeminyï¼‰</label><br>
        <label><input type="radio" name="rhythm" value="pvc_multifocal"> å¤šæºæ€§æœŸå¤–åç¸®</label><br>
        <label><input type="radio" name="rhythm" value="shortRun"> ã‚·ãƒ§ãƒ¼ãƒˆãƒ©ãƒ³ï¼ˆNSVTï¼‰</label><br>
        <label><input type="radio" name="rhythm" value="ronT"> RonTç¾è±¡</label>
      </fieldset>
    </div>
    <div class="card">
      <h2>ç´™é€ã‚Šãƒ»æ„Ÿåº¦</h2>
      <div class="row">
        <label for="speed" class="pill">é€Ÿåº¦</label>
        <input id="speed" type="range" min="10" max="50" value="25" aria-label="ç´™é€ã‚Šé€Ÿåº¦">
        <span id="speedLbl">25</span> mm/s
      </div>
      <div class="row">
        <label for="gain" class="pill">æ„Ÿåº¦</label>
        <input id="gain" type="range" min="5" max="20" value="10" aria-label="æ„Ÿåº¦">
        <span id="gainLbl">10</span> mm/mV
      </div>
      <div class="row">
        <label for="leadSel" class="pill">èª˜å°</label>
        <select id="leadSel" aria-label="èª˜å°é¸æŠ">
          <option value="II" selected>II</option>
          <option value="I">I</option>
          <option value="III">III</option>
          <option value="aVR">aVR</option>
          <option value="aVL">aVL</option>
          <option value="aVF">aVF</option>
          <option value="V1">V1</option>
          <option value="V2">V2</option>
          <option value="V3">V3</option>
          <option value="V4">V4</option>
          <option value="V5">V5</option>
          <option value="V6">V6</option>
        </select>
      </div>
      <p class="grid-note">å¤§ãƒã‚¹=5 mmï¼ˆ200 ms / 0.5 mVï¼‰ã€å°ãƒã‚¹=1 mmï¼ˆ40 ms / 0.1 mVï¼‰</p>
  <p class="grid-note">ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ: <span class="kbd">Space</span> å†ç”Ÿ/åœæ­¢ãƒ»<span class="kbd">R</span> ãƒªã‚»ãƒƒãƒˆãƒ»<span class="kbd">S</span> PNGä¿å­˜ãƒ»<span class="kbd">[</span>/<span class="kbd">]</span> é€Ÿåº¦ãƒ»<span class="kbd">-</span>/<span class="kbd">+</span> æ„Ÿåº¦</p>
    </div>
    
  </aside>
  <main>
    <section class="card">
      <div class="row row-between align-end">
        <h2 class="h2-tight">ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ³¢å½¢</h2>
        <div>å¿ƒæ‹æ•°: <span id="hr" aria-live="polite" aria-atomic="true">â€”</span> /min</div>
      </div>
      <div id="stage">
  <!-- Grid and Wave canvases -->
  <canvas id="gridCanvas" width="1200" height="320" aria-hidden="true"></canvas>
  <canvas id="ecgCanvas" width="1200" height="320" role="img" aria-label="ECG æ³¢å½¢è¡¨ç¤ºã‚­ãƒ£ãƒ³ãƒã‚¹">ECG æ³¢å½¢ã‚’è¡¨ç¤ºã™ã‚‹ã‚­ãƒ£ãƒ³ãƒã‚¹</canvas>
      </div>
  <div class="row row-between mt-8">
        <button class="btn" id="pause" aria-pressed="true">â¯ å†ç”Ÿ/ä¸€æ™‚åœæ­¢</button>
        <button class="btn" id="reset">â†º ãƒªã‚»ãƒƒãƒˆ</button>
  <button class="btn" id="savePng" title="ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ç”»åƒä¿å­˜">ğŸ–¼ PNGä¿å­˜</button>
  
      </div>
    </section>
    <!-- moved from sidebar: å­¦ç¿’ãƒ¡ãƒ¢ & ãƒªã‚ºãƒ è§£èª¬ã‚’ECGã®ä¸‹ã¸é…ç½®ï¼ˆé †åºã‚’ã€Œãƒªã‚ºãƒ è§£èª¬ â†’ å­¦ç¿’ãƒ¡ãƒ¢ã€ã«å¤‰æ›´ï¼‰ -->
    <section class="card">
      <h2>ãƒªã‚ºãƒ è§£èª¬</h2>
      <div id="rhythmInfo" class="grid-note prewrap" aria-live="polite" aria-atomic="true"></div>
    </section>
    <section class="card">
      <h2>å­¦ç¿’ãƒ¡ãƒ¢</h2>
      <ul>
        <li>P â†’ PR â†’ QRS â†’ ST/T â†’ QTc ã®é †ã§ãƒã‚§ãƒƒã‚¯</li>
        <li>QRSå¹… â‰¥120 ms ã§ bundle branch block ã‚„å¿ƒå®¤èµ·æºã‚’è€ƒãˆã‚‹</li>
        <li>è¦å‰‡æ€§ Ã— QRSå¹… Ã— Pã®é–¢ä¿‚ ã§é »è„ˆã‚’é‘‘åˆ¥</li>
      </ul>
      <p class="grid-note">æ–¹çœ¼ã¯25Â mm/sãƒ»10Â mm/mVåŸºæº–ã§æç”»ã•ã‚Œã¦ã„ã¾ã™ã€‚</p>
    </section>
  </main>
</div>
<script>
// ======= ECG Drawing Logic (Canvas scroll) =======
let running = true;
const waveCanvas = document.getElementById('ecgCanvas');
const gridCanvas = document.getElementById('gridCanvas');
const ctx = waveCanvas.getContext && waveCanvas.getContext('2d');
const gtx = gridCanvas.getContext && gridCanvas.getContext('2d');
if(!ctx){
  alert('ãŠä½¿ã„ã®ãƒ–ãƒ©ã‚¦ã‚¶ã§ã¯CanvasãŒæœ‰åŠ¹ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚æœ€æ–°ã®ãƒ–ãƒ©ã‚¦ã‚¶ã‚’ã”åˆ©ç”¨ãã ã•ã„ã€‚');
}
let mmPerSec = 25;     // speed 25 mm/s
let mmPerMv = 10;      // gain 10 mm/mV
const basePxPerMM = 4; // 1 mm = 4 CSS pixels
let pxPerMM = basePxPerMM * (window.devicePixelRatio || 1); // device px
let t = 0;             // elapsed ms
let lastTS = performance.now();
let rhythm = 'sinus';
let rrSchedule = [];
let cycleMs = 800;
let phase = 0;
// Solid ECG line rendering state
let lastDrawY = null;

// Additional state for complex rhythms
let beatCounter = 0;           // counts the number of completed beats
let currentPVCSign = 1;        // sign multiplier for multifocal PVCs
let ronCounter = 0;            // counter for RonT cycles
const ronInterval = 6;         // interval of beats between R-on-T events
let ronFlag = false;           // indicates if current cycle should include an R-on-T overlay
let nextRRIdx = 0;
let W = waveCanvas.width;   // device px
let H = waveCanvas.height;  // device px
let baselineY = H*0.6;
// Lead selection and phase segmentation for P/QRS/T scaling
let lead = 'II';
let lastSeg = {pr:160, qrs:90, qt:400};
const LEAD_COEFF = {
  I:{p:0.7,qrs:0.7,t:0.6}, II:{p:1.0,qrs:1.0,t:1.0}, III:{p:0.85,qrs:0.85,t:0.9},
  aVR:{p:-0.5,qrs:-0.6,t:-0.5}, aVL:{p:0.4,qrs:0.4,t:0.4}, aVF:{p:0.9,qrs:0.95,t:0.9},
  V1:{p:0.3,qrs:-0.6,t:-0.3}, V2:{p:0.4,qrs:-0.4,t:-0.2}, V3:{p:0.5,qrs:0.1,t:0.2},
  V4:{p:0.7,qrs:0.6,t:0.4}, V5:{p:0.8,qrs:0.9,t:0.6}, V6:{p:0.7,qrs:0.85,t:0.6}
};
function setSeg(pr,qrs,qt){ lastSeg = {pr, qrs, qt}; }
function applyLeadScaling(val, p){
  const coeff = LEAD_COEFF[lead] || LEAD_COEFF.II;
  const pr = lastSeg.pr ?? 160; const qrs = lastSeg.qrs ?? 90; const qt = lastSeg.qt ?? 400;
  const pEnd = Math.max(60, pr * 0.75);
  const qrsEnd = pr + qrs;
  const tEnd = pr + qt;
  let scale = coeff.t;
  if(p < pEnd) scale = coeff.p;
  else if(p < qrsEnd) scale = coeff.qrs;
  else if(p < tEnd) scale = coeff.t;
  return val * scale;
}

// Beat-level dynamic state (e.g., Wenckebach/Mobitz)
let currentPR = 160;         // ms; used for rhythms with dynamic PR
let wenckCount = 0;          // 0..(wenckLen-1)
const wenckLen = 5;          // pattern: 4 conducted (PRæ¼¸å»¶) + 1 drop
const wenckPRstart = 160;    // starting PR
const wenckPRstep = 40;      // PR prolongation per conducted beat
let wenckDropThisBeat = false;

let mobitzCount = 0;         // Mobitz II drop cadence
const mobitzLen = 3;         // 2 conducted : 1 drop
let mobitzDropThisBeat = false;

function msToPx(ms){ return (ms/1000)*mmPerSec * pxPerMM; }
function mvToPx(mv){ return -mv*mmPerMv * pxPerMM; }
function drawGrid(){
  const bg = getComputedStyle(document.documentElement).getPropertyValue('--bg') || '#0b101a';
  const sm = getComputedStyle(document.documentElement).getPropertyValue('--grid-sm') || 'rgba(255,255,255,0.06)';
  const lg = getComputedStyle(document.documentElement).getPropertyValue('--grid-lg') || 'rgba(255,255,255,0.10)';
  gtx.fillStyle = bg; gtx.fillRect(0,0,W,H);
  gtx.lineWidth = 1;
  gtx.strokeStyle = sm;
  for(let x=0; x<=W; x+=pxPerMM){ gtx.beginPath(); gtx.moveTo(x,0); gtx.lineTo(x,H); gtx.stroke(); }
  for(let y=0; y<=H; y+=pxPerMM){ gtx.beginPath(); gtx.moveTo(0,y); gtx.lineTo(W,y); gtx.stroke(); }
  gtx.strokeStyle = lg;
  for(let x=0; x<=W; x+=pxPerMM*5){ gtx.beginPath(); gtx.moveTo(x,0); gtx.lineTo(x,H); gtx.stroke(); }
  for(let y=0; y<=H; y+=pxPerMM*5){ gtx.beginPath(); gtx.moveTo(0,y); gtx.lineTo(W,y); gtx.stroke(); }
}

// morphological functions referencing typical ECG metrics
// Gaussian helper to produce smooth waveforms
function gauss(x, mu, sigma, amp){
  const z = (x - mu) / sigma;
  return amp * Math.exp(-0.5 * z * z);
}

// Asymmetric Gaussian: different sigma for left/right sides to shape Tæ³¢ã®å·¦å³éå¯¾ç§°
function skewGauss(x, mu, sigmaL, sigmaR, amp){
  const sigma = x < mu ? sigmaL : sigmaR;
  const z = (x - mu) / sigma;
  return amp * Math.exp(-0.5 * z * z);
}

/**
 * Generate a single heartbeat morphology using sums of Gaussians.
 *
 * Parameters:
 *  pr  â€“ PR interval (ms) from P onset to QRS onset
 *  qrs â€“ QRS duration (ms)
 *  qt  â€“ QT interval (ms) from QRS onset to end of T wave
 *  pAmp/qAmp/rAmp/sAmp/tAmp â€“ amplitudes (mV) of the P, Q, R, S and T components
 *
 * Returns a millivolt value at a given phase p (0 â‰¤ p < cycle length).
 */
function morphBasic(p, opts){
  const {pr=160, qrs=90, qt=380, pAmp=0.25, qAmp=-0.05, rAmp=1.0, sAmp=-0.15, tAmp=0.25, tSkew=1.3, uAmp=0.0} = opts;
  let mv=0;
  // P wave â€“ small positive deflection; centre at 40 ms with more rounded shape
  mv += skewGauss(p, 40, 25, 25, pAmp);
  // Q wave â€“ small negative deflection at onset of QRS; centre slightly after PR onset
  const qrsScale = Math.max(0.8, qrs / 90);
  mv += gauss(p, pr + qrs * 0.1, 10 * qrsScale, qAmp);
  // R wave â€“ tall positive deflection; centre midâ€‘QRS
  mv += gauss(p, pr + qrs * 0.35, 12 * qrsScale, rAmp);
  // S wave â€“ small negative deflection towards end of QRS
  mv += gauss(p, pr + qrs * 0.7, 10 * qrsScale, sAmp);
  // T wave â€“ broad, rounded wave after QRS; centre halfway through T interval
  const tDur = qt - qrs;
  const tCenter = pr + qrs + tDur * 0.5;
  const tSigma = tDur * 0.22;
  // skewed T for more physiological look (slow return)
  mv += skewGauss(p, tCenter, tSigma * tSkew, tSigma / tSkew, tAmp);
  // Optional U wave: small slow positive deflection after T
  if(uAmp){
    const uCenter = tCenter + tDur * 0.55;
    mv += gauss(p, uCenter, tDur * 0.25, uAmp);
  }
  return mv;
}
// arrhythmia-specific morphological modifications
// drop: when true, represent non-conducted beat (P present but no QRS/T)
function morphValue(kind,p, drop=false){
  switch(kind){
  case 'sinus': setSeg(160,90,400); return morphBasic(p, {pr:160,qrs:90,qt:400,pAmp:0.22,qAmp:-0.04,rAmp:1.0,sAmp:-0.12,tAmp:0.30,tSkew:1.4,uAmp:0.03});
    case 'avb1': {
      const basePR = 220;
      const drift = 30 * Math.sin(2*Math.PI*((t%6000)/6000));
      setSeg(basePR + drift, 90, 400);
      return morphBasic(p, {pr: basePR + drift, qrs:90, qt:400, pAmp:0.25, qAmp:-0.05, rAmp:1.0, sAmp:-0.12, tAmp:0.32});
    }
    case 'rbbb':{
      // Wide QRS (140ms) with RSR' pattern: add second R at end; attenuate S amplitude
      setSeg(160,140,420);
      let mv = morphBasic(p, {pr:160,qrs:140,qt:420,pAmp:0.18,qAmp:-0.03,rAmp:0.9,sAmp:-0.04,tAmp:0.26,tSkew:1.5});
      // R' bump at late QRS
      // Add late R' bump for right bundle branch block
      mv += gauss(p, 160 + 140 - 30, 10, 0.5);
      // subtle notching just before R'
      mv -= gauss(p, 160 + 140 - 45, 8, 0.08);
      return mv;
    }
    case 'lbbb':{
      // Wide notched R, absence of Q; negative S slight; T inversion suppressed
  setSeg(160,160,460);
  let mv = morphBasic(p, {pr:160,qrs:160,qt:460,pAmp:0.16,qAmp:0.0,rAmp:0.85,sAmp:-0.03,tAmp:0.22,tSkew:1.6});
      // Broader R plateau
      // Add broad plateau at early QRS to simulate notched R in left bundle branch block
      mv += gauss(p,160 + 30,20,0.6);
      return mv;
    }
    case 'psvt':{
      // Narrow QRS, rapid HR; P often hidden; approximate as QRS only
      setSeg(60,70,320);
      return morphBasic(p,{pr:60,qrs:70,qt:320,pAmp:0.04,qAmp:-0.05,rAmp:0.9,sAmp:-0.1,tAmp:0.22,tSkew:1.3});
    }
    case 'vt':{
      setSeg(20,320,540);
      return morphBasic(p,{pr:20,qrs:480,qt:540,pAmp:0.0,qAmp:-0.22,rAmp:1.3,sAmp:-0.42,tAmp:0.05,tSkew:1.0});
    }
    case 'mobitz2': {
      if(drop){ setSeg(currentPR,0,320); return morphBasic(p,{pr:currentPR,qrs:0,qt:320,pAmp:0.25,qAmp:0,rAmp:0,sAmp:0,tAmp:0}); }
      setSeg(currentPR,90,380);
      return morphBasic(p,{pr:currentPR,qrs:90,qt:380,pAmp:0.25,qAmp:-0.05,rAmp:1.0,sAmp:-0.15,tAmp:0.30});
    }
    case 'wenckebach':{
      if(drop){ setSeg(currentPR,0,320); return morphBasic(p,{pr:currentPR,qrs:0,qt:320,pAmp:0.25,qAmp:0,rAmp:0,sAmp:0,tAmp:0}); }
      setSeg(currentPR,90,380);
      return morphBasic(p,{pr:currentPR,qrs:90,qt:380,pAmp:0.25,qAmp:-0.05,rAmp:1.0,sAmp:-0.15,tAmp:0.30});
    }
    case 'chb':{
      const atrialCycle = 750; // ~80 bpm
      const atrialP = gauss((t%atrialCycle), 40, 20, 0.22);
      setSeg(0,180,500);
      const vent = morphBasic(p,{pr:0,qrs:180,qt:500,pAmp:0.0,qAmp:-0.12,rAmp:0.9,sAmp:-0.24,tAmp:0.06});
      return atrialP + vent;
    }
    case 'af':{
      // Add fibrillatory baseline noise and irregular small waves; plus occasional narrow QRS
      // Baseline: multiple small harmonics with slowly drifting phases (use global time t)
      const f = 0.02*Math.sin(2*Math.PI*((t%400)/400))
               +0.018*Math.sin(2*Math.PI*((t%250)/250) + 0.7)
               +0.014*Math.sin(2*Math.PI*((t%180)/180) + 1.1)
               +0.010*Math.sin(2*Math.PI*((t%120)/120) + 2.0);
      setSeg(60,80,320);
      return f + morphBasic(p,{pr:60,qrs:80,qt:320,pAmp:0.0,qAmp:-0.05,rAmp:1.0,sAmp:-0.15,tAmp:0.22,tSkew:1.3});
    }
    case 'vf':{
      // Chaotic: slower and larger for legibility
      setSeg(0, cycleMs*0.5, cycleMs*0.9);
      let mv=0;
      for(let i=1;i<=6;i++){
        const freq = 7 + Math.random()*5;
        mv += 0.12*Math.sin(2*Math.PI*(t/1000*freq) + i*0.8);
      }
      return mv;
    }
    case 'afl':{
      // Atrial flutter: sawtooth F waves ~300 bpm with 2:1 conduction; sharpened asymmetry
      setSeg(100,80,360);
      const base = morphBasic(p,{pr:100,qrs:80,qt:360,pAmp:0.0,qAmp:-0.05,rAmp:1.0,sAmp:-0.12,tAmp:0.20});
      const period = 200; // ms (~300/min)
      const pos = p % period;
      // Sawtooth: slow rise then sharp drop
      const rise = Math.min(1, pos/(period*0.8));
      const fall = pos >= period*0.8 ? (1 - (pos - period*0.8)/(period*0.2)) : 1;
      const fWave = 0.22 * (rise * fall);
      return base + fWave;
    }
    case 'wpw':{
      // Short PR with delta wave (slurred upstroke) and potentially wider QRS
      const pr = 90; const qrs = 120; const qt = 410;
      setSeg(pr,qrs,qt);
      let mv = morphBasic(p,{pr,qrs,qt,pAmp:0.18,qAmp:-0.02,rAmp:0.95,sAmp:-0.10,tAmp:0.26,tSkew:1.3});
      // Delta wave: stronger, slower initial upstroke after P end
      mv += skewGauss(p, pr + qrs*0.10, 36, 18, 0.28);
      return mv;
    }
    case 'earlyRepol':{
      // Normal PR/QRS with J-point notch and concave ST elevation, tall T
      const pr=160,qrs=90,qt=400;
      setSeg(pr,qrs,qt);
      let mv = morphBasic(p,{pr,qrs,qt,pAmp:0.20,qAmp:-0.03,rAmp:0.95,sAmp:-0.10,tAmp:0.38,tSkew:1.5});
      // J-notch at QRS end
      mv += gauss(p, pr + qrs + 6, 8, 0.15);
      // Concave ST elevation (gentle offset before T)
      const tStart = pr + qrs;
      if(p > tStart && p < tStart + 120){ mv += 0.08 * (1 - (p - tStart)/120); }
      return mv;
    }
    case 'stElevation':{
      // ST elevation with convexity, S above baseline
      const pr=160,qrs=90,qt=400;
      setSeg(pr,qrs,qt);
      let mv = morphBasic(p,{pr,qrs,qt,pAmp:0.18,qAmp:-0.03,rAmp:0.95,sAmp:0.02,tAmp:0.26,tSkew:1.2});
      const stStart = pr + qrs;
      if(p > stStart && p < stStart + 160){ mv += 0.22 * (1 - Math.pow((p - stStart)/160, 0.7)); }
      return mv;
    }
    case 'stDepression':{
      // Horizontal/downsloping ST depression, flattened or inverted T
      const pr=160,qrs=90,qt=380;
      setSeg(pr,qrs,qt);
      let mv = morphBasic(p,{pr,qrs,qt,pAmp:0.18,qAmp:-0.04,rAmp:0.95,sAmp:-0.10,tAmp:-0.08,tSkew:1.2});
      const stStart = pr + qrs;
      if(p > stStart && p < stStart + 160){ mv -= 0.15; }
      return mv;
    }
    case 'hypoK':{
      // Hypokalemia: ST depression, flattened T, negative U per request
      const pr=180,qrs=90,qt=420;
      setSeg(pr,qrs,qt);
      let mv = morphBasic(p,{pr,qrs,qt,pAmp:0.18,qAmp:-0.04,rAmp:0.95,sAmp:-0.10,tAmp:0.06,uAmp:-0.14,tSkew:1.2});
      const stStart = pr + qrs;
      if(p > stStart && p < stStart + 180){ mv -= 0.08; }
      return mv;
    }
    case 'hyperK':{
      // Hyperkalemia: tall peaked T, small/absent P, QRS widening (moderate)
      const pr=140,qrs=120,qt=380;
      setSeg(pr,qrs,qt);
      return morphBasic(p,{pr,qrs,qt,pAmp:0.05,qAmp:-0.02,rAmp:0.85,sAmp:-0.10,tAmp:0.55,tSkew:1.0});
    }
    case 'qtcLong':{
      // QT prolongation
      const pr=160,qrs=90,qt=520;
      setSeg(pr,qrs,qt);
      return morphBasic(p,{pr,qrs,qt,pAmp:0.18,qAmp:-0.04,rAmp:0.95,sAmp:-0.10,tAmp:0.28,uAmp:0.04,tSkew:1.5});
    }
    case 'qtcShort':{
      // QT shortening with sharper T
      const pr=160,qrs=90,qt=300;
      setSeg(pr,qrs,qt);
      return morphBasic(p,{pr,qrs,qt,pAmp:0.18,qAmp:-0.04,rAmp:0.95,sAmp:-0.10,tAmp:0.36,tSkew:1.1});
    }
    case 'torsades':{
      // Torsades de pointes: polymorphic VT with twisting QRS amplitude around the baseline
      // Use a wide QRS and modulate amplitude and axis over a multi-second envelope
      // Base waveform with wide QRS and modest repolarisation; amplify to emphasise polymorphic nature
  setSeg(0,260,520);
  const base = morphBasic(p,{pr:0,qrs:400,qt:520,pAmp:0.0,qAmp:-0.30,rAmp:1.25,sAmp:-0.48,tAmp:0.10});
      // Envelope varies slowly (~3Â s) to produce waxing and waning amplitude
  const env = 0.55 + 0.45 * Math.sin(2 * Math.PI * ((t % 3500) / 3500));
  // Alternate polarity over ~7 s to simulate axis rotation
  const sign = Math.sign(Math.sin(2 * Math.PI * ((t % 7000) / 7000))) || 1;
      return base * env * sign;
    }
    case 'pvc_single':
    case 'pvc_frequent':
    case 'pvc_multifocal':
    case 'shortRun':{
      // PVC variants: use schedule to determine if current cycle is a PVC (cycleMs < 800)
      const isPVC = cycleMs < 800;
      if(isPVC){
        // multifocal PVCs have varying polarity; assign at start of cycle
  if(kind === 'pvc_multifocal' && p < 1){ currentPVCSign = (currentPVCSign===1 ? -1 : 1); }
  const amp = (kind === 'pvc_multifocal' ? currentPVCSign : 1);
  setSeg(0,240,520);
  return amp * morphBasic(p,{pr:0,qrs:240,qt:520,pAmp:0.0,qAmp:-0.18,rAmp:1.25,sAmp:-0.40,tAmp:0.10});
      } else {
        // normal beat
        setSeg(160,90,400);
        return morphBasic(p,{pr:160,qrs:90,qt:400,pAmp:0.22,qAmp:-0.04,rAmp:1.0,sAmp:-0.12,tAmp:0.30,tSkew:1.4});
      }
    }
    case 'ronT':{
      // R-on-T phenomenon: place PVC on T wave
      setSeg(160,90,400);
      let mv = morphBasic(p,{pr:160,qrs:90,qt:400,pAmp:0.22,qAmp:-0.04,rAmp:1.0,sAmp:-0.12,tAmp:0.30,tSkew:1.4});
      if(ronFlag){
        const qrsOnset = 160; // ms (PR)
        const tStart = qrsOnset + 90;
        const start = tStart + 70; // on T upslope
        const width = 180;
        if(p >= start && p <= start + width){
          // overlay PVC; use PVC segmentation for scaling
          setSeg(0,180,480);
          mv += morphBasic(p - start,{pr:0,qrs:180,qt:480,pAmp:0.0,qAmp:-0.18,rAmp:1.25,sAmp:-0.40,tAmp:0.10});
        }
      }
      return mv;
    }
    default: return morphBasic(p, {});
  }
}

// RR schedule (ms) per rhythm
function schedule(kind){
  switch(kind){
    case 'sinus': return [800];
    case 'avb1': return [900];
    case 'rbbb': return [800];
    case 'lbbb': return [800];
    case 'psvt': return [300];
    case 'vt': return [450];
    case 'af': return Array.from({length:6},()=> 500 + Math.random()*500);
    case 'mobitz2': return [800];
    case 'wenckebach': return [800];
    case 'chb': return [1000];
  case 'vf': return Array.from({length:6},()=> 250 + Math.random()*250);
    case 'afl': return [400];
    case 'torsades': return [500];
    case 'wpw': return [800];
    case 'earlyRepol': return [800];
    case 'stElevation': return [800];
    case 'stDepression': return [800];
    case 'hypoK': return [900];
    case 'hyperK': return [800];
    case 'qtcLong': return [900];
    case 'qtcShort': return [700];
    case 'pvc_single':{
      // 1ã¤ã®PVCï¼šæ•°æ‹æ´èª¿å¾‹â†’æ—©æœŸçµåˆï¼ˆ600msï¼‰â†’ä»£å„Ÿä¼‘æ­¢ï¼ˆ~1000msï¼‰
      const base = 800;
      const jitter = () => (Math.random()*30-15);
      return [base+jitter(), base+jitter(), base+jitter(), 600+jitter(), 1000+jitter(), base+jitter()];
    }
    case 'pvc_frequent':{
      // äºŒæ®µè„ˆï¼ˆbigeminyï¼‰è¿‘å‚ï¼šæ´æ‹â†’çµåˆâ†’ä»£å„Ÿä¼‘æ­¢ã®ç¹°ã‚Šè¿”ã—
      const jitter = () => (Math.random()*30-15);
      return [800+jitter(), 600+jitter(), 1000+jitter(), 800+jitter(), 600+jitter(), 1000+jitter()];
    }
    case 'pvc_multifocal':{
      // çµåˆé–“éš”ã¨ä»£å„Ÿä¼‘æ­¢ã«è»½ã„ãƒãƒ©ãƒ„ã‚­ã€å½¢ã‚‚å¾Œã§æ¥µæ€§åè»¢
      const jitter = () => (Math.random()*40-20);
      return [820+jitter(), 580+jitter(), 1040+jitter(), 790+jitter(), 610+jitter(), 980+jitter()];
    }
  case 'shortRun': return [780,520,500,500,520,780];
    case 'ronT': return [800];
    default: return [800];
  }
}
function updateCycle(){
  // Advance to next cycle in the schedule. If the rhythm uses a repeating pattern
  // (i.e. rrSchedule length > 1), step through the array; otherwise repeat the first value.
  if(rhythm === 'wenckebach'){
    // Link RR to PR prolongation and dropped beats: slight shortening before drop, pause after drop
    const base = 800;
    const shortBy = 20 * Math.max(0, Math.min(wenckCount, wenckLen-2));
    if(wenckDropThisBeat){
      cycleMs = base + 260 + (Math.random()*40-20); // pause after dropped beat (< 2*RR)
    } else {
      cycleMs = base - shortBy + (Math.random()*20-10);
    }
  }
  else if(rhythm === 'af' || rhythm === 'vf' || rrSchedule.length > 1){
    cycleMs = rrSchedule[nextRRIdx % rrSchedule.length];
    nextRRIdx++;
  } else {
    cycleMs = rrSchedule[0];
  }
}

function shouldDrop(kind){
  if(kind==='mobitz2'){
    return mobitzDropThisBeat;
  }
  if(kind==='wenckebach'){
    return wenckDropThisBeat;
  }
  if(kind==='chb') return false;
  return false;
}

function scrollAndDraw(val){
  // shift left by 1px
  const img = ctx.getImageData(1,0,W-1,H);
  ctx.putImageData(img, 0,0);
  // clear rightmost line
  ctx.clearRect(W-1,0,1,H);
  // draw point
  const y = baselineY + mvToPx(val);
  // solid line segment between previous and current sample - color based on theme
  ctx.strokeStyle = document.body.classList.contains('light-mode') ? '#000000' : '#5eead4';
  ctx.lineWidth = 2;
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  if(lastDrawY == null){ lastDrawY = y; }
  ctx.beginPath();
  ctx.moveTo(W-2, lastDrawY);
  ctx.lineTo(W-1, y);
  ctx.stroke();
  lastDrawY = y;
}

function animate(ts){
  if(!running){ requestAnimationFrame(animate); return; }
  let dt = ts - lastTS; lastTS = ts;
  const msPerPix = 1000*(1/pxPerMM)/mmPerSec;
  let acc = dt;
  while(acc > 0){
    // update sample and draw
    const drop = shouldDrop(rhythm);
  const v = morphValue(rhythm, phase, drop);
  const vl = applyLeadScaling(v, phase);
  scrollAndDraw(vl);
    const step = msPerPix;
    t += step; phase += step; acc -= step;
    if(phase >= cycleMs){
      phase -= cycleMs;
      // A beat has completed
      beatCounter++;
      // Determine whether upcoming cycle should include an R-on-T event
      if(rhythm === 'ronT'){
        ronCounter++;
        ronFlag = (ronCounter % ronInterval) === (ronInterval - 1);
      } else {
        ronFlag = false;
      }

      // Update beat-level conduction patterns
      if(rhythm === 'wenckebach'){
        // pattern: 4 conducted with progressive PR, then a dropped beat
        wenckCount = (wenckCount + 1) % wenckLen;
        if(wenckCount === wenckLen - 1){
          wenckDropThisBeat = true;
          currentPR = wenckPRstart; // reset for next conducted cycle
        } else {
          wenckDropThisBeat = false;
          currentPR = wenckPRstart + wenckPRstep * wenckCount;
        }
      } else {
        wenckDropThisBeat = false;
      }

      if(rhythm === 'mobitz2'){
        // pattern: conduct, conduct, drop, repeat (fixed PR)
        mobitzCount = (mobitzCount + 1) % mobitzLen;
        mobitzDropThisBeat = (mobitzCount === mobitzLen - 1);
        currentPR = 200;
      } else {
        mobitzDropThisBeat = false;
      }

      updateCycle();
    }
  }
  requestAnimationFrame(animate);
}

// init
function init(){
  drawGrid();
  rrSchedule = schedule(rhythm);
  updateCycle();
  phase = 0; t = 0; lastTS = performance.now();
  beatCounter = 0;
  ronCounter = 0;
  ronFlag = false;
  // reset AV block states
  currentPR = 160; wenckCount = 0; wenckDropThisBeat = false; mobitzCount = 0; mobitzDropThisBeat = false;
  // reflect play state to button
  const pauseBtn = document.getElementById('pause');
  if(pauseBtn){ pauseBtn.setAttribute('aria-pressed', String(running)); }
  lastDrawY = null;
}
init();
requestAnimationFrame((ts)=>{ lastTS=ts; requestAnimationFrame(animate); });

// High-DPI and responsive canvas sizing
function resizeCanvas(){
  const dpr = window.devicePixelRatio || 1;
  const rect = waveCanvas.getBoundingClientRect();
  const cssW = Math.max(600, Math.floor(rect.width));
  const cssH = Math.floor(rect.height);
  waveCanvas.width = Math.floor(cssW * dpr);
  waveCanvas.height = Math.floor(cssH * dpr);
  gridCanvas.width = Math.floor(cssW * dpr);
  gridCanvas.height = Math.floor(cssH * dpr);
  pxPerMM = basePxPerMM * dpr;
  W = waveCanvas.width; H = waveCanvas.height; baselineY = H * 0.6;
  drawGrid();
  lastDrawY = null;
}
window.addEventListener('resize', resizeCanvas);
// initial fit after styles applied
setTimeout(resizeCanvas, 0);

// UI bindings
const radios = document.querySelectorAll('input[name="rhythm"]');
radios.forEach(r=> r.addEventListener('change', ()=>{
  rhythm = r.value;
  // persist
  try{ localStorage.setItem('ecg.r', rhythm); }catch{}
  rrSchedule = schedule(rhythm);
  nextRRIdx = 0;
  // reset counters and flags for new rhythm
  beatCounter = 0;
  ronCounter = 0;
  ronFlag = false;
  updateCycle();
  phase = 0;
  t = 0;
  drawGrid();
  // update info panel
  updateRhythmInfo();
  lastDrawY = null;
}));

document.getElementById('pause').addEventListener('click', ()=>{ 
  running = !running; 
  const btn = document.getElementById('pause');
  if(btn){ btn.setAttribute('aria-pressed', String(running)); }
  if(running) lastTS = performance.now(); 
});

document.getElementById('reset').addEventListener('click', ()=>{
  drawGrid();
  phase = 0;
  t = 0;
  beatCounter = 0;
  ronCounter = 0;
  ronFlag = false;
  currentPR = 160; wenckCount = 0; wenckDropThisBeat = false; mobitzCount = 0; mobitzDropThisBeat = false;
  // reset controls to defaults
  const speedEl = document.getElementById('speed');
  const gainEl = document.getElementById('gain');
  if(speedEl){ speedEl.value = '25'; mmPerSec = 25; document.getElementById('speedLbl').textContent = '25'; try{ localStorage.setItem('ecg.v', '25'); }catch{} }
  if(gainEl){ gainEl.value = '10'; mmPerMv = 10; document.getElementById('gainLbl').textContent = '10'; try{ localStorage.setItem('ecg.g', '10'); }catch{} }
  lastDrawY = null;
});

document.getElementById('speed').addEventListener('input', (e)=>{ mmPerSec = +e.target.value; document.getElementById('speedLbl').textContent = mmPerSec; try{ localStorage.setItem('ecg.v', String(mmPerSec)); }catch{} });

document.getElementById('gain').addEventListener('input', (e)=>{ mmPerMv = +e.target.value; document.getElementById('gainLbl').textContent = mmPerMv; try{ localStorage.setItem('ecg.g', String(mmPerMv)); }catch{} });

// Lead selector
const leadSel = document.getElementById('leadSel');
leadSel?.addEventListener('change', ()=>{ lead = leadSel.value; try{ localStorage.setItem('ecg.lead', lead); }catch{} });

// caliper functionality removed; no interactive measurement tool

// HR display update with moving average of last N RR
const rrHistory = [];
const rrAvgLen = 5;
setInterval(()=>{
  rrHistory.push(cycleMs);
  if(rrHistory.length > rrAvgLen) rrHistory.shift();
  const avg = rrHistory.reduce((a,b)=>a+b,0)/rrHistory.length;
  const bpm = Math.round(60000 / avg);
  document.getElementById('hr').textContent = isFinite(bpm)? bpm: 'â€”';
}, 300);

// Save PNG
document.getElementById('savePng').addEventListener('click', ()=>{
  const tmp = document.createElement('canvas');
  tmp.width = W; tmp.height = H;
  const tctx = tmp.getContext('2d');
  tctx.drawImage(gridCanvas, 0, 0);
  tctx.drawImage(waveCanvas, 0, 0);
  const url = tmp.toDataURL('image/png');
  const a = document.createElement('a');
  a.href = url; a.download = 'ecg.png'; a.click();
});

// R-wave detection removed per request

// Rhythm explanations
const RHY_THUMBS = {
  sinus: {
    title: 'æ´èª¿å¾‹',
    text: 'æ­£å¸¸ã®é›»æ°—ä¼å°ã€‚æ´çµç¯€â†’å¿ƒæˆ¿â†’æˆ¿å®¤çµç¯€â†’His-Purkinjeç³»â†’å¿ƒå®¤ã¸ã¨é †åºè‰¯ãä¼å°ã—ã¾ã™ã€‚è¦å‰‡çš„ãªPæ³¢ã€ä¸€å®šã®PRã€ç‹­ã„QRSã€åŒæ–¹å‘ã®TãŒç‰¹å¾´ã§ã™ã€‚'
  },
  avb1: {
    title: '1åº¦æˆ¿å®¤ãƒ–ãƒ­ãƒƒã‚¯',
    text: 'æˆ¿å®¤çµç¯€ã®é…å»¶ã§PRé–“éš”ãŒå…¨æ‹ã§å»¶é•·ã€‚ãŸã ã—å…¨ã¦ä¼å°ã—ã€QRSã¯ç‹­ã„ã¾ã¾ã€‚æ©Ÿåºã¯AVçµç¯€ã§ã®ä¼å°é…å»¶ã€‚'
  },
  wenckebach: {
    title: '2åº¦æˆ¿å®¤ãƒ–ãƒ­ãƒƒã‚¯ï¼ˆWenckebachãƒ»Mobitz Iï¼‰',
    text: 'PRãŒæ‹æ¯ã«æ¼¸å¢—ã—ã€ã¤ã„ã«1æ‹è„±è½ï¼ˆãƒ‰ãƒ­ãƒƒãƒ—ï¼‰ã€‚ãã®å¾ŒPRã¯çŸ­ããƒªã‚»ãƒƒãƒˆã€‚æ©Ÿåºã¯AVçµç¯€ãƒ¬ãƒ™ãƒ«ã®ç–²å¼Šæ€§ä¼å°ã€‚'
  },
  mobitz2: {
    title: '2åº¦æˆ¿å®¤ãƒ–ãƒ­ãƒƒã‚¯ï¼ˆMobitz IIï¼‰',
    text: 'PRã¯ä¸€å®šã®ã¾ã¾çªç„¶QRSãŒè„±è½ã€‚æ©Ÿåºã¯HisæŸä»¥ä¸‹ï¼ˆè„šãƒ–ãƒ­ãƒƒã‚¯é ˜åŸŸï¼‰ã§ã®ä¼å°éšœå®³ã§ã€äºˆå¾Œä¸Šé‡è¦–ã€‚QRSã¯åºƒã„ã“ã¨ã‚‚ã€‚'
  },
  chb: {
    title: 'å®Œå…¨æˆ¿å®¤ãƒ–ãƒ­ãƒƒã‚¯',
    text: 'å¿ƒæˆ¿ã¨å¿ƒå®¤ãŒè§£é›¢ã€‚å¿ƒæˆ¿ã¯æ´èª¿å¾‹ã€å¿ƒå®¤ã¯è£œå……èª¿å¾‹ï¼ˆå¾æ‹ãƒ»åºƒã„QRSï¼‰ã§è‡ªå¾‹ã€‚Pã¨QRSã®é–¢ä¿‚æ¶ˆå¤±ã€‚æ©Ÿåºã¯AVçµç¯€/ä¸‹ä½ã®å®Œå…¨é®æ–­ã€‚'
  },
  rbbb: {
    title: 'å³è„šãƒ–ãƒ­ãƒƒã‚¯ï¼ˆRBBBï¼‰',
    text: 'å³è„šã®ä¼å°é…å»¶ã§å¿ƒå®¤ä¸­éš”â†’å·¦å®¤â†’æœ€å¾Œã«å³å®¤ãŒèˆˆå¥®ã€‚QRSã¯åºƒãã€æœ«æ¢¢ã§Râ€™ï¼ˆäºŒå³°æ€§ï¼‰ã‚’ç¤ºã—ã¾ã™ï¼ˆèª˜å°ä¾å­˜ï¼‰ã€‚'
  },
  lbbb: {
    title: 'å·¦è„šãƒ–ãƒ­ãƒƒã‚¯ï¼ˆLBBBï¼‰',
    text: 'å·¦è„šã®ä¼å°é…å»¶ã§å³å®¤â†’å·¦å®¤ã®é †ã«èˆˆå¥®ã€‚QRSã¯åºƒãã€ãƒãƒƒãƒ/ãƒ—ãƒ©ãƒˆãƒ¼ã€äºŒæ¬¡æ€§ST-Tå¤‰åŒ–ï¼ˆdiscordantï¼‰ã‚’ä¼´ã„ã¾ã™ã€‚'
  },
  psvt: {
    title: 'ç™ºä½œæ€§ä¸Šå®¤é »æ‹ï¼ˆPSVTï¼‰',
    text: 'æˆ¿å®¤çµç¯€ãƒªã‚¨ãƒ³ãƒˆãƒªãƒ¼ç­‰ã«ã‚ˆã‚Šç‹­ã„QRSã§æ€¥é€Ÿãƒ»è¦å‰‡çš„ã€‚Pã¯QRSã«åŸ‹æ²¡/é€†è¡Œæ€§ã¨ãªã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚'
  },
  vt: {
    title: 'å¿ƒå®¤é »æ‹ï¼ˆVTï¼‰',
    text: 'å¿ƒå®¤èµ·æºã®è¦å‰‡çš„é »æ‹ã€‚QRSã¯åºƒãå˜å½¢/å¤šå½¢ã€‚æˆ¿å®¤è§£é›¢ã‚„æ•æ‰/èåˆæ‹ãŒæ‰€è¦‹ã€‚æ©Ÿåºã¯ç˜¢ç—•éƒ¨ãƒªã‚¨ãƒ³ãƒˆãƒªãƒ¼ç­‰ã€‚'
  },
  torsades: {
    title: 'ãƒˆãƒ«ã‚µãƒ¼ãƒ‰ãƒ»ãƒ‰ãƒ»ãƒãƒ¯ãƒ³ãƒ„ï¼ˆTdPï¼‰',
    text: 'å¤šå½¢æ€§VTã®ä¸€ç¨®ã§QRSæŒ¯å¹…ãŒåŸºç·šå‘¨ã‚Šã«ã­ã˜ã‚Œã‚‹ã‚ˆã†ã«å¤‰å‹•ã€‚å…ˆè¡ŒQTå»¶é•·ãŒèƒŒæ™¯ã€‚æ—©æœŸå¾Œè„±åˆ†æ¥µãŒæ©Ÿåºã€‚'
  },
  vf: {
    title: 'å¿ƒå®¤ç´°å‹•ï¼ˆVFï¼‰',
    text: 'å¿ƒå®¤ãŒç„¡ç§©åºã«ç´°å‹•ã—æ‹å‡ºä¸èƒ½ã€‚ä¸è¦å‰‡ã§ç„¡æ–¹å‘æ€§ã®é«˜é »åº¦æ´»å‹•ã€‚ç›´ã¡ã«é™¤ç´°å‹•ãŒå¿…è¦ã€‚'
  },
  af: {
    title: 'å¿ƒæˆ¿ç´°å‹•ï¼ˆAFï¼‰',
    text: 'å¿ƒæˆ¿ãŒå¾®ç´°ãªç„¡ç§©åºèˆˆå¥®ã§åç¸®ã›ãšã€‚RRã¯å®Œå…¨ä¸è¦å‰‡ã€fæ³¢ãŒåŸºç·šã®æºã‚Œã¨ã—ã¦ç¾ã‚Œã¾ã™ã€‚AVçµç¯€ã®ä¸è¦å‰‡ä¼å°ãŒæ©Ÿåºã€‚'
  },
  afl: {
    title: 'å¿ƒæˆ¿ç²—å‹•ï¼ˆAFLï¼‰',
    text: 'å¿ƒæˆ¿ãƒã‚¯ãƒ­ãƒªã‚¨ãƒ³ãƒˆãƒªãƒ¼ã§é‹¸æ­¯çŠ¶Fæ³¢ï¼ˆ~300/minï¼‰ã€‚ä¼å°æ¯”ï¼ˆ2:1ç­‰ï¼‰ã§å¿ƒå®¤ãƒ¬ãƒ¼ãƒˆãŒæ±ºã¾ã‚Šã¾ã™ã€‚'
  },
  wpw: {
    title: 'WPWç—‡å€™ç¾¤ï¼ˆãƒ‡ãƒ«ã‚¿æ³¢ï¼‰',
    text: 'å‰¯ä¼å°è·¯ï¼ˆKentæŸï¼‰ã‚’ä»‹ã—ãŸå¿ƒå®¤æ—©æœŸèˆˆå¥®ã€‚çŸ­PRã¨QRSåˆæœŸã®ãªã ã‚‰ã‹ãªç«‹ã¡ä¸ŠãŒã‚Šï¼ˆãƒ‡ãƒ«ã‚¿æ³¢ï¼‰ãŒç‰¹å¾´ã€‚ãƒªã‚¨ãƒ³ãƒˆãƒªãƒ¼é »æ‹ã®åŸºç›¤ã¨ãªã‚Šå¾—ã¾ã™ã€‚'
  },
  earlyRepol: {
    title: 'æ—©æœŸå†åˆ†æ¥µ',
    text: 'å¥å¸¸è‹¥å¹´ç”·æ€§ãªã©ã«å¤šã„ç”Ÿç†çš„æ‰€è¦‹ã€‚Jç‚¹ä¸Šæ˜‡ã‚„ãƒãƒƒãƒã€ä¸Šå‘ãå‡¹çŠ¶ã®STä¸Šæ˜‡ã¨é«˜ã„Tæ³¢ã€‚è™šè¡€æ€§STä¸Šæ˜‡ã¨ã®é‘‘åˆ¥ãŒé‡è¦ã€‚'
  },
  stElevation: {
    title: 'STä¸Šæ˜‡',
    text: 'æ€¥æ€§å† ç—‡å€™ç¾¤ãƒ»å¿ƒè†œç‚ãƒ»æ—©æœŸå†åˆ†æ¥µãªã©ã§è¦‹ã‚‰ã‚Œã‚‹ã€‚å‡¸å‹ã‚„åºƒç¯„å›²ã®ä¸Šæ˜‡ã¯è™šè¡€ã‚’ç¤ºå”†ã—ã†ã‚‹ãŸã‚è¦æ³¨æ„ï¼ˆè‡¨åºŠæ–‡è„ˆã§è©•ä¾¡ï¼‰ã€‚'
  },
  stDepression: {
    title: 'STä½ä¸‹',
    text: 'å¿ƒç­‹è™šè¡€ãƒ»è² è·æ™‚å¤‰åŒ–ãƒ»äºŒæ¬¡æ€§å¤‰åŒ–ãªã©ã€‚æ°´å¹³/ä¸‹é™å‚¾æ–œã®STä½ä¸‹ã¯è™šè¡€ã®å¯èƒ½æ€§ã€‚Tæ³¢å¹³å¦åŒ–/é™°è»¢ã‚’ä¼´ã†ã“ã¨ã‚ã‚Šã€‚'
  },
  hypoK: {
    title: 'ä½ã‚«ãƒªã‚¦ãƒ è¡€ç—‡',
    text: 'STä½ä¸‹ã€Tæ³¢å¹³å¦åŒ–ã€Uæ³¢å¢—é«˜ãŒç‰¹å¾´ã€‚æœŸå¤–åç¸®ã‚„ãƒˆãƒ«ã‚µãƒ¼ãƒ‰ã®ãƒªã‚¹ã‚¯ä¸Šæ˜‡ã€‚è£œæ­£ã¨åŸå› æ¤œç´¢ãŒå¿…è¦ã€‚'
  },
  hyperK: {
    title: 'é«˜ã‚«ãƒªã‚¦ãƒ è¡€ç—‡',
    text: 'å°–é‹­ãªãƒ†ãƒ³ãƒˆçŠ¶Tæ³¢ã€PRå»¶é•·ã€Pæ³¢æ¸›é«˜/æ¶ˆå¤±ã€QRSå»¶é•·ï½æ´åœæ­¢/å¿ƒé™æ­¢ã¸ç§»è¡Œã—å¾—ã‚‹ã€‚ç·Šæ€¥å¯¾å¿œãŒå¿…è¦ã€‚'
  },
  qtcLong: {
    title: 'QTå»¶é•·',
    text: 'å…ˆå¤©æ€§/å¾Œå¤©æ€§è¦å› ï¼ˆè–¬å‰¤ãƒ»é›»è§£è³ªç•°å¸¸ï¼‰ã§QTãŒå»¶é•·ã€‚æ—©æœŸå¾Œè„±åˆ†æ¥µâ†’TdPã®ãƒªã‚¹ã‚¯ã€‚å¿ƒæ‹è£œæ­£QTcã§è©•ä¾¡ã€‚'
  },
  qtcShort: {
    title: 'QTçŸ­ç¸®',
    text: 'å…ˆå¤©æ€§çŸ­QTç—‡å€™ç¾¤ã‚„é«˜Caè¡€ç—‡ãªã©ã§è¦³å¯Ÿã€‚Tæ³¢ãŒå°–é‹­ãƒ»é–“éš”çŸ­ç¸®ã€‚ä¸Šå®¤/å¿ƒå®¤æ€§ä¸æ•´è„ˆãƒªã‚¹ã‚¯ã«ç•™æ„ã€‚'
  },
  pvc_single: {
    title: 'å¿ƒå®¤æœŸå¤–åç¸®ï¼ˆå˜ç™ºï¼‰',
    text: 'æ—©æœŸã®å¿ƒå®¤èµ·æºæ‹ã§åºƒã„QRSã€‚çµæ»ï¼ˆçµåˆé–“éš”çŸ­ç¸®ï¼‰ã¨ä»£å„Ÿæ€§ä¼‘æ­¢ãŒè¦‹ã‚‰ã‚Œã¾ã™ã€‚'
  },
  pvc_frequent: {
    title: 'é »ç™ºPVCï¼ˆä¾‹ï¼šäºŒæ®µè„ˆï¼‰',
    text: 'æ´èª¿å¾‹ã«PVCãŒäº¤äº’ã«æ··åœ¨ï¼ˆäºŒæ®µè„ˆï¼‰ã€‚ä»£å„Ÿæ€§ä¼‘æ­¢ã«ã‚ˆã‚Šç­‰é–“éš”ã«è¦‹ãˆã‚‹ã“ã¨ã‚‚ã€‚'
  },
  pvc_multifocal: {
    title: 'å¤šæºæ€§PVC',
    text: 'å½¢ã®ç•°ãªã‚‹PVCãŒè¤‡æ•°ç„¦ç‚¹ã‹ã‚‰ç™ºç”Ÿã€‚æ¥µæ€§ãƒ»å½¢æ…‹ãŒæ‹ã”ã¨ã«å¤‰ã‚ã‚Šã¾ã™ã€‚'
  },
  shortRun: {
    title: 'ã‚·ãƒ§ãƒ¼ãƒˆãƒ©ãƒ³ï¼ˆéæŒç¶šæ€§VTï¼‰',
    text: 'æ•°æ‹ã®VTãŒé€£ç™ºã—ã¦è‡ªç„¶åœæ­¢ã€‚åŸºç¤ãƒªã‚ºãƒ ã«çŸ­ã„VTã‚¨ãƒ”ã‚½ãƒ¼ãƒ‰ãŒæŒ¿å…¥ã•ã‚Œã¾ã™ã€‚'
  },
  ronT: {
    title: 'R-on-Tç¾è±¡',
    text: 'Tæ³¢ä¸Šã®æ—©æœŸå¿ƒå®¤æ€§æœŸå¤–åç¸®ã€‚è„†å¼±æœŸã¸ã®åˆºæ¿€ã§è‡´æ­»æ€§ä¸æ•´è„ˆã‚’èª˜ç™ºã—ã†ã‚‹ãŸã‚è¦æ³¨æ„ã€‚'
  }
};

function updateRhythmInfo(){
  const info = RHY_THUMBS[rhythm];
  const el = document.getElementById('rhythmInfo');
  if(!el) return;
  if(info){
    el.innerText = `ã€${info.title}ã€‘\n${info.text}`;
  } else {
    el.innerText = '';
  }
}

// init info once
updateRhythmInfo();

// Theme toggle + persistence
const themeBtn = document.getElementById('themeToggle');
function applyTheme(theme){
  document.documentElement.setAttribute('data-theme', theme);
  try{ localStorage.setItem('ecg.theme', theme); }catch{}
  if(themeBtn){ themeBtn.textContent = theme === 'light' ? 'â˜€ï¸' : 'ğŸŒ™'; themeBtn.setAttribute('aria-pressed', theme === 'light' ? 'true' : 'false'); }
  drawGrid();
}
const savedTheme = (()=>{ try{ return localStorage.getItem('ecg.theme'); }catch{ return null; } })();
if(savedTheme){ applyTheme(savedTheme); }
themeBtn?.addEventListener('click', ()=>{
  const current = document.documentElement.getAttribute('data-theme') || 'dark';
  applyTheme(current === 'light' ? 'dark' : 'light');
});

// Restore saved controls
try{
  const sv = localStorage.getItem('ecg.v');
  const sg = localStorage.getItem('ecg.g');
  const sr = localStorage.getItem('ecg.r');
  const sLead = localStorage.getItem('ecg.lead');
  if(sv){ mmPerSec = +sv; const el=document.getElementById('speed'); if(el){ el.value = sv; document.getElementById('speedLbl').textContent = sv; } }
  if(sg){ mmPerMv = +sg; const el=document.getElementById('gain'); if(el){ el.value = sg; document.getElementById('gainLbl').textContent = sg; } }
  if(sr){ rhythm = sr; const r = document.querySelector(`input[name="rhythm"][value="${sr}"]`); if(r){ r.checked = true; } rrSchedule = schedule(rhythm); updateRhythmInfo(); }
  if(sLead){ lead = sLead; const el = document.getElementById('leadSel'); if(el){ el.value = sLead; } }
}catch{}

// Keyboard shortcuts
window.addEventListener('keydown', (e)=>{
  if(e.target && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA')) return;
  switch(e.key){
    case ' ': e.preventDefault(); document.getElementById('pause').click(); break;
    case 'r': case 'R': document.getElementById('reset').click(); break;
    case 's': case 'S': document.getElementById('savePng').click(); break;
    case '[': mmPerSec = Math.max(10, mmPerSec - 1); document.getElementById('speed').value = String(mmPerSec); document.getElementById('speedLbl').textContent = String(mmPerSec); try{ localStorage.setItem('ecg.v', String(mmPerSec)); }catch{} break;
    case ']': mmPerSec = Math.min(50, mmPerSec + 1); document.getElementById('speed').value = String(mmPerSec); document.getElementById('speedLbl').textContent = String(mmPerSec); try{ localStorage.setItem('ecg.v', String(mmPerSec)); }catch{} break;
    case '-': mmPerMv = Math.max(5, mmPerMv - 1); document.getElementById('gain').value = String(mmPerMv); document.getElementById('gainLbl').textContent = String(mmPerMv); try{ localStorage.setItem('ecg.g', String(mmPerMv)); }catch{} break;
    case '+': case '=': mmPerMv = Math.min(20, mmPerMv + 1); document.getElementById('gain').value = String(mmPerMv); document.getElementById('gainLbl').textContent = String(mmPerMv); try{ localStorage.setItem('ecg.g', String(mmPerMv)); }catch{} break;
    case 't': case 'T': themeBtn?.click(); break;
  }
});

// Pause animation when tab not visible
let wasRunning = true;
document.addEventListener('visibilitychange', ()=>{
  if(document.hidden){ wasRunning = running; running = false; const btn=document.getElementById('pause'); if(btn){ btn.setAttribute('aria-pressed','false'); } }
  else { running = wasRunning; const btn=document.getElementById('pause'); if(btn){ btn.setAttribute('aria-pressed', String(running)); } if(running) lastTS = performance.now(); }
});
</script>
<footer class="site-footer">Â© 2025 Toyo Medical College, Emergency Life-saving Technician Department, Ippei Tanaka</footer>
</body>
</html>
