<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>心電図テスト</title>
<meta name="theme-color" content="#0b1220" media="(prefers-color-scheme: dark)">
<meta name="theme-color" content="#ffffff" media="(prefers-color-scheme: light)">
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-3K0XSVMYL7"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-3K0XSVMYL7');
</script>
<style>
  :root{
    --bg:#0b1220; --panel:#111a2b; --ink:#e6edf3; --muted:#98a2b3; --accent:#5eead4; --warn:#f97316;
    --grid-sm: rgba(255,255,255,0.06); --grid-lg: rgba(255,255,255,0.10);
    --btn-bg:#17243b; --btn-bd:#27406a; --btn-ink:var(--ink);
  }
  html[data-theme="light"]{
    --bg:#ffffff; --panel:#ffffff; --ink:#0b1220; --muted:#475569; --accent:#0ea5e9; --warn:#ea580c;
    --grid-sm: rgba(234, 84, 98, 0.22);
    --grid-lg: rgba(234, 84, 98, 0.45);
    --btn-bg:#f8fafc; --btn-bd:#dbe3ea; --btn-ink:#0b1220;
  }
  html,body{height:100%; margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; color:var(--ink); background:var(--bg);} 
  html:not([data-theme="light"]) body, html:not([data-theme="light"]) { background:linear-gradient(180deg,#0a0f1b 0%, #0e1526 40%, #111827 100%);} 
  .wrap{display:grid; grid-template-columns: 1fr; height:100%}
  header{display:flex; justify-content:space-between; align-items:center; padding:12px 16px; background:var(--panel); border-bottom:1px solid #1f2b3f}
  .btn{background:var(--btn-bg); color:var(--btn-ink); border:1px solid var(--btn-bd); padding:8px 12px; border-radius:10px; cursor:pointer; text-decoration:none; display:inline-block}
  main{padding:16px}
  #stage{position:relative; height:340px}
  #stage canvas{position:absolute; left:0; top:0}
  canvas{display:block; width:100%; height:320px; border-radius:12px; border:none; background:transparent}
  #gridCanvas{background:var(--bg); border:1px solid #253554;}
  #ecgCanvas{background:transparent;}
  .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
  .pill{display:inline-block; padding:4px 8px; border-radius:999px; background:#13223a; border:1px solid #20304f; font-size:12px; color:var(--muted)}
  .answer{font-size:16px; color:var(--ink)}
  .controls{background:rgba(255,255,255,0.03); border:1px solid #22304a; border-radius:12px; padding:12px; margin:12px 0}
  .control-group{display:flex; gap:12px; align-items:center; flex-wrap:wrap}
  .control-group label{color:var(--muted); font-size:12px; min-width:40px}
  .control-group input[type="range"]{flex:1; min-width:80px}
  .control-group select{background:var(--btn-bg); color:var(--btn-ink); border:1px solid var(--btn-bd); padding:4px 8px; border-radius:6px}
  footer.site-footer{ margin-top:8px; padding:12px 16px; background:var(--panel); border-top:1px solid #1f2b3f; color:var(--muted); font-size:12px; text-align:center }
  /* Test page keeps single-column layout on small screens */
</style>
</head>
<body>
<header>
  <div class="row">
    <a class="btn" href="index.html">← 戻る</a>
  </div>
  <div class="row">
    <button class="btn" id="reveal">解答</button>
    <button class="btn" id="next">次へ</button>
  </div>
</header>
<main>
  <div class="pill">ランダム出題: 現在の描画と同じ物理スケール</div>
  
  <div class="controls">
    <div class="control-group">
      <label for="speed">速度</label>
      <input id="speed" type="range" min="10" max="50" value="25">
      <span id="speedLbl">25</span> mm/s
      
  <label for="gain">感度</label>
  <input id="gain" type="range" min="5" max="20" value="20">
  <span id="gainLbl">20</span> mm/mV
      
      <label for="leadSel">誘導</label>
      <select id="leadSel">
        <option value="II" selected>II</option>
        <option value="I">I</option>
        <option value="III">III</option>
        <option value="aVR">aVR</option>
        <option value="aVL">aVL</option>
        <option value="aVF">aVF</option>
        <option value="V1">V1</option>
        <option value="V2">V2</option>
        <option value="V3">V3</option>
        <option value="V4">V4</option>
        <option value="V5">V5</option>
        <option value="V6">V6</option>
      </select>
    </div>
  </div>
  
  <div id="stage">
    <canvas id="gridCanvas" width="1200" height="320" aria-hidden="true"></canvas>
    <canvas id="ecgCanvas" width="1200" height="320" role="img" aria-label="ECG 波形表示キャンバス">ECG 波形を表示するキャンバス</canvas>
  </div>
  <p class="answer" id="ans" aria-live="polite"></p>
</main>
<footer class="site-footer">© 2025 Toyo Medical College, Emergency Life-saving Technician Department, Ippei Tanaka</footer>
<script>
// Shared drawing parameters (copy minimal parts from index.html)
let running = true;
const waveCanvas = document.getElementById('ecgCanvas');
const gridCanvas = document.getElementById('gridCanvas');
const ctx = waveCanvas.getContext('2d');
const gtx = gridCanvas.getContext('2d');
let mmPerSec = 25; let mmPerMv = 20; const basePxPerMM = 4; let pxPerMM = basePxPerMM * (window.devicePixelRatio||1);
let t = 0; let lastTS = performance.now();
let rhythm = 'sinus'; let rrSchedule = []; let phase = 0; let nextRRIdx=0; let currentRR = 800;
let W = waveCanvas.width; let H = waveCanvas.height; let baselineY = H*0.6; let lastDrawY=null;
let beatCounter=0; let ronCounter=0; let ronFlag=false;
let currentPR = 160; let wenckCount=0; const wenckLen=5; const wenckPRstart=140; const wenckPRstep=60; let wenckDropThisBeat=false; let mobitzCount=0; const mobitzLen=3; let mobitzDropThisBeat=false;
let currentPVCSign=1;
// frame time accumulator for stable stepping
let accMS = 0;

// Lead scaling - independent of main page
let lead = 'II';
const LEAD_COEFF = {
  I:{p:0.7,qrs:0.7,t:0.6}, II:{p:1.0,qrs:1.0,t:1.0}, III:{p:0.85,qrs:0.85,t:0.9},
  aVR:{p:-0.5,qrs:-0.6,t:-0.5}, aVL:{p:0.4,qrs:0.4,t:0.4}, aVF:{p:0.9,qrs:0.95,t:0.9},
  V1:{p:0.3,qrs:-0.6,t:-0.3}, V2:{p:0.4,qrs:-0.4,t:-0.2}, V3:{p:0.5,qrs:0.1,t:0.2},
  V4:{p:0.7,qrs:0.6,t:0.4}, V5:{p:0.8,qrs:0.9,t:0.6}, V6:{p:0.7,qrs:0.85,t:0.6}
};
let lastSeg = {pr:160,qrs:90,qt:400};
function setSeg(pr,qrs,qt){ lastSeg = {pr,qrs,qt}; }
function applyLeadScaling(val, p){
  const c = LEAD_COEFF[lead] || LEAD_COEFF.II;
  const pr = lastSeg.pr ?? 160; const qrs = lastSeg.qrs ?? 90; const qt = lastSeg.qt ?? 400;
  const pEnd = Math.max(60, pr * 0.75);
  const qrsEnd = pr + qrs;
  const tEnd = pr + qt;
  let s = c.t;
  if(p < pEnd) s = c.p; else if(p < qrsEnd) s = c.qrs; else if(p < tEnd) s = c.t;
  return val * s;
}

function msToPx(ms){ return (ms/1000)*mmPerSec * pxPerMM; }
function mvToPx(mv){ return -mv*mmPerMv * pxPerMM; }
function drawGrid(){
  const cs = getComputedStyle(document.documentElement);
  const bg = cs.getPropertyValue('--bg') || '#0b101a';
  const sm = cs.getPropertyValue('--grid-sm') || 'rgba(255,255,255,0.06)';
  const lg = cs.getPropertyValue('--grid-lg') || 'rgba(255,255,255,0.10)';
  gtx.fillStyle = bg; gtx.fillRect(0,0,W,H);
  gtx.lineWidth = 1;
  gtx.strokeStyle = sm;
  for(let x=0; x<=W; x+=pxPerMM){ gtx.beginPath(); gtx.moveTo(x,0); gtx.lineTo(x,H); gtx.stroke(); }
  for(let y=0; y<=H; y+=pxPerMM){ gtx.beginPath(); gtx.moveTo(0,y); gtx.lineTo(W,y); gtx.stroke(); }
  gtx.strokeStyle = lg;
  for(let x=0; x<=W; x+=pxPerMM*5){ gtx.beginPath(); gtx.moveTo(x,0); gtx.lineTo(x,H); gtx.stroke(); }
  for(let y=0; y<=H; y+=pxPerMM*5){ gtx.beginPath(); gtx.moveTo(0,y); gtx.lineTo(W,y); gtx.stroke(); }
}
function gauss(x, mu, sigma, amp){ const z=(x-mu)/sigma; return amp*Math.exp(-0.5*z*z); }
function skewGauss(x, mu, sigmaL, sigmaR, amp){ const s=x<mu? sigmaL:sigmaR; const z=(x-mu)/s; return amp*Math.exp(-0.5*z*z); }
function morphBasic(p, opts){
  const {pr=160, qrs=90, qt=380, pAmp=0.25, qAmp=-0.05, rAmp=1.0, sAmp=-0.15, tAmp=0.25, tSkew=1.3, uAmp=0.0} = opts;
  let mv=0; mv += skewGauss(p, 40, 32, 32, pAmp);
  const qrsScale = Math.max(0.8, (opts.qrs||90) / 90);
  mv += gauss(p, pr + qrs * 0.1, 10*qrsScale, qAmp);
  mv += gauss(p, pr + qrs * 0.35, 12*qrsScale, rAmp);
  mv += gauss(p, pr + qrs * 0.7, 10*qrsScale, sAmp);
  const tDur = qt - qrs; const tCenter = pr + qrs + tDur * 0.5; const tSigma = tDur * 0.22;
  mv += skewGauss(p, tCenter, tSigma * tSkew, tSigma / tSkew, tAmp);
  if(uAmp){ const uCenter = tCenter + tDur * 0.55; mv += gauss(p, uCenter, tDur * 0.25, uAmp); }
  return mv;
}
function morphValue(kind, p, drop = false) {
  switch (kind) {
    case 'sinus':
      setSeg(160, 90, 400);
      return morphBasic(p, { pr: 160, qrs: 90, qt: 400, pAmp: 0.22, qAmp: -0.04, rAmp: 1.0, sAmp: -0.12, tAmp: 0.30, tSkew: 1.4, uAmp: 0.03 });

    case 'sinusArrest': {
      // 洞停止: 非整数倍のPP間隔の長い休止。休止サイクルではフラット。
      if(currentRR > 1200){ setSeg(0,0,0); return 0; }
      setSeg(160,90,400);
      return morphBasic(p, { pr: 160, qrs: 90, qt: 400, pAmp: 0.22, qAmp: -0.04, rAmp: 1.0, sAmp: -0.12, tAmp: 0.30, tSkew: 1.4, uAmp: 0.03 });
    }

    case 'saBlock': {
      // 洞房ブロック（II型を想定）: 2PPの休止。休止サイクルはフラット。
      if(currentRR >= 1500){ setSeg(0,0,0); return 0; }
      setSeg(160,90,400);
      return morphBasic(p, { pr: 160, qrs: 90, qt: 400, pAmp: 0.22, qAmp: -0.04, rAmp: 1.0, sAmp: -0.12, tAmp: 0.30, tSkew: 1.4, uAmp: 0.03 });
    }

    case 'avb1': {
      // I度房室ブロック: PRが徐々に延長（例: 10秒で160→360ms）。脱落はしない。
      const period = 10000; // 10s
      const f = (t % period) / period;
      const prNow = 160 + f * (360 - 160);
      setSeg(prNow, 90, 420);
      return morphBasic(p, { pr: prNow, qrs: 90, qt: 420, pAmp: 0.28, qAmp: -0.05, rAmp: 1.0, sAmp: -0.12, tAmp: 0.32 });
    }

    case 'rbbb': {
      setSeg(160, 140, 420);
      let mv = morphBasic(p, { pr: 160, qrs: 140, qt: 420, pAmp: 0.18, qAmp: -0.03, rAmp: 0.9, sAmp: -0.04, tAmp: 0.26, tSkew: 1.5 });
      mv += gauss(p, 160 + 140 - 30, 10, 0.5);
      mv -= gauss(p, 160 + 140 - 45, 8, 0.08);
      return mv;
    }

    case 'lbbb': {
      const pr = 160, qrs = 170, qt = 480;
      setSeg(pr, qrs, qt);
      let mv = morphBasic(p, { pr, qrs, qt, pAmp: 0.14, qAmp: 0.0, rAmp: 0.95, sAmp: -0.02, tAmp: -0.28, tSkew: 1.4 });
      mv += gauss(p, pr + qrs * 0.35, 18, 0.35);
      mv -= gauss(p, pr + qrs * 0.55, 14, 0.12);
      mv += gauss(p, pr + qrs * 0.72, 16, 0.28);
      return mv;
    }

    case 'psvt':
      setSeg(60, 70, 320);
      return morphBasic(p, { pr: 60, qrs: 70, qt: 320, pAmp: 0.04, qAmp: -0.05, rAmp: 0.9, sAmp: -0.1, tAmp: 0.22, tSkew: 1.3 });

    case 'vt':
      setSeg(20, 320, 540);
      return morphBasic(p, { pr: 20, qrs: 480, qt: 540, pAmp: 0.0, qAmp: -0.22, rAmp: 1.3, sAmp: -0.42, tAmp: 0.05, tSkew: 1.0 });

    case 'mobitz2': {
      if (drop) {
        setSeg(currentPR, 0, 320);
        return morphBasic(p, { pr: currentPR, qrs: 0, qt: 320, pAmp: 0.25, qAmp: 0, rAmp: 0, sAmp: 0, tAmp: 0 });
      }
      setSeg(currentPR, 90, 380);
      return morphBasic(p, { pr: currentPR, qrs: 90, qt: 380, pAmp: 0.25, qAmp: -0.05, rAmp: 1.0, sAmp: -0.15, tAmp: 0.30 });
    }

    case 'wenckebach': {
      if (drop) {
        setSeg(currentPR, 0, 320);
        return morphBasic(p, { pr: currentPR, qrs: 0, qt: 320, pAmp: 0.25, qAmp: 0, rAmp: 0, sAmp: 0, tAmp: 0 });
      }
      setSeg(currentPR, 90, 380);
      return morphBasic(p, { pr: currentPR, qrs: 90, qt: 380, pAmp: 0.25, qAmp: -0.05, rAmp: 1.0, sAmp: -0.15, tAmp: 0.30 });
    }

    case 'chb': {
      const atrialCycle = 750;
      // より丸いP波（skewGaussでσ≈32ms、対称）
      const atrialPhase = (t % atrialCycle);
      const atrialP = skewGauss(atrialPhase, 40, 32, 32, 0.22);
      setSeg(0, 180, 500);
      const vent = morphBasic(p, { pr: 0, qrs: 180, qt: 500, pAmp: 0.0, qAmp: -0.12, rAmp: 0.9, sAmp: -0.24, tAmp: 0.06 });
      return atrialP + vent;
    }

    case 'af': {
      const seed = Math.floor(t / 1000) * 1000;
      let f = 0;
      for (let i = 0; i < 6; i++) {
        const freq = 4 + i * 0.8;
        const phase = ((seed * (i + 1) * 0.00001) % 1) * 2 * Math.PI;
        const amp = 0.04 * (1 - i * 0.1);
        f += amp * Math.sin(2 * Math.PI * freq * (t % 1000) * 0.001 + phase);
      }
      setSeg(60, 80, 320);
      return f + morphBasic(p, { pr: 60, qrs: 80, qt: 320, pAmp: 0.0, qAmp: -0.05, rAmp: 1.0, sAmp: -0.15, tAmp: 0.22, tSkew: 1.3 });
    }

    case 'vf': {
      setSeg(0, cycleMs * 0.5, cycleMs * 0.9);
      const seed = Math.floor(t / 50) * 50;
      let mv = 0;
      for (let i = 0; i < 6; i++) {
        const freq = 8 + i * 1.2;
        const phase = ((seed * (i + 1) * 0.00001) % 1) * 2 * Math.PI;
        const amp = 0.3 * (1 - i * 0.12);
        mv += amp * Math.sin(2 * Math.PI * freq * (t % 50) * 0.001 + phase);
      }
      return mv;
    }

    case 'afl': {
      // Clearer sawtooth F-waves: fast rise (~15%), slow decay (~85%), higher amplitude
      setSeg(100, 80, 360);
      const base = morphBasic(p, { pr: 100, qrs: 80, qt: 360, pAmp: 0.0, qAmp: -0.05, rAmp: 1.0, sAmp: -0.12, tAmp: 0.20 });
      const period = 200; // ~300/min
      const f = (p % period) / period;
      const tooth = f < 0.15 ? (f / 0.15) : (1 - (f - 0.15) / 0.85);
      const fWave = 0.30 * (tooth * 2 - 1);
      return base + fWave;
    }

    case 'wpw': {
      const pr = 90, qrs = 120, qt = 410;
      setSeg(pr, qrs, qt);
      let mv = morphBasic(p, { pr, qrs, qt, pAmp: 0.18, qAmp: -0.02, rAmp: 0.95, sAmp: -0.10, tAmp: 0.26, tSkew: 1.3 });
      mv += skewGauss(p, pr + qrs * 0.10, 36, 18, 0.28);
      return mv;
    }

    case 'earlyRepol': {
      const pr = 160, qrs = 90, qt = 400;
      setSeg(pr, qrs, qt);
      let mv = morphBasic(p, { pr, qrs, qt, pAmp: 0.20, qAmp: -0.03, rAmp: 0.95, sAmp: -0.10, tAmp: 0.38, tSkew: 1.5 });
      mv += gauss(p, pr + qrs + 6, 8, 0.15);
      const tStart = pr + qrs;
      if (p > tStart && p < tStart + 120) {
        mv += 0.08 * (1 - (p - tStart) / 120);
      }
      return mv;
    }

    case 'stElevation': {
      const pr = 160, qrs = 90, qt = 400;
      setSeg(pr, qrs, qt);
      let mv = morphBasic(p, { pr, qrs, qt, pAmp: 0.18, qAmp: -0.03, rAmp: 0.95, sAmp: 0.02, tAmp: 0.26, tSkew: 1.2 });
      const stStart = pr + qrs;
      if (p > stStart && p < stStart + 160) {
        mv += 0.22 * (1 - Math.pow((p - stStart) / 160, 0.7));
      }
      return mv;
    }

    case 'stDepression': {
      const pr = 160, qrs = 90, qt = 380;
      setSeg(pr, qrs, qt);
      let mv = morphBasic(p, { pr, qrs, qt, pAmp: 0.18, qAmp: -0.04, rAmp: 0.95, sAmp: -0.10, tAmp: -0.08, tSkew: 1.2 });
      const stStart = pr + qrs;
      if (p > stStart && p < stStart + 160) {
        mv -= 0.15;
      }
      return mv;
    }

    case 'hypoK': {
      const pr = 180, qrs = 90, qt = 420;
      setSeg(pr, qrs, qt);
      let mv = morphBasic(p, { pr, qrs, qt, pAmp: 0.18, qAmp: -0.04, rAmp: 0.95, sAmp: -0.10, tAmp: 0.06, uAmp: -0.14, tSkew: 1.2 });
      const stStart = pr + qrs;
      if (p > stStart && p < stStart + 180) {
        mv -= 0.08;
      }
      return mv;
    }

    case 'hyperK':
      setSeg(140, 120, 380);
      return morphBasic(p, { pr: 140, qrs: 120, qt: 380, pAmp: 0.05, qAmp: -0.02, rAmp: 0.85, sAmp: -0.10, tAmp: 0.55, tSkew: 1.0 });

    case 'qtcLong':
      setSeg(160, 90, 520);
      return morphBasic(p, { pr: 160, qrs: 90, qt: 520, pAmp: 0.18, qAmp: -0.04, rAmp: 0.95, sAmp: -0.10, tAmp: 0.28, uAmp: 0.04, tSkew: 1.5 });

    case 'qtcShort':
      setSeg(160, 90, 300);
      return morphBasic(p, { pr: 160, qrs: 90, qt: 300, pAmp: 0.18, qAmp: -0.04, rAmp: 0.95, sAmp: -0.10, tAmp: 0.36, tSkew: 1.1 });

    case 'torsades': {
      setSeg(0, 320, 580);
      const base = morphBasic(p, { pr: 0, qrs: 480, qt: 580, pAmp: 0.0, qAmp: -0.35, rAmp: 1.4, sAmp: -0.55, tAmp: 0.10 });
      const env = 0.55 + 0.45 * Math.sin(2 * Math.PI * ((t % 3500) / 3500));
      const sign = Math.sign(Math.sin(2 * Math.PI * ((t % 7000) / 7000))) || 1;
      return base * env * sign;
    }

    case 'pvc_single':
    case 'pvc_frequent':
    case 'pvc_multifocal':
    case 'shortRun': {
      const isPVC = currentRR < 800;
      if (isPVC) {
        if (kind === 'pvc_multifocal' && p < 1) {
          currentPVCSign = (currentPVCSign === 1 ? -1 : 1);
        }
        const amp = (kind === 'pvc_multifocal' ? currentPVCSign : 1);
        setSeg(0, 240, 520);
        return amp * morphBasic(p, { pr: 0, qrs: 240, qt: 520, pAmp: 0.0, qAmp: -0.18, rAmp: 1.25, sAmp: -0.40, tAmp: 0.10 });
      } else {
        setSeg(160, 90, 400);
        return morphBasic(p, { pr: 160, qrs: 90, qt: 400, pAmp: 0.22, qAmp: -0.04, rAmp: 1.0, sAmp: -0.12, tAmp: 0.30, tSkew: 1.4 });
      }
    }

    case 'ronT': {
      setSeg(160, 90, 400);
      let mv = morphBasic(p, { pr: 160, qrs: 90, qt: 400, pAmp: 0.22, qAmp: -0.04, rAmp: 1.0, sAmp: -0.12, tAmp: 0.30, tSkew: 1.4 });
      if (ronFlag) {
        const qrsOnset = 160;
        const tStart = qrsOnset + 90;
        const start = tStart + 70;
        const width = 180;
        if (p >= start && p <= start + width) {
          setSeg(0, 180, 480);
          mv += morphBasic(p - start, { pr: 0, qrs: 180, qt: 480, pAmp: 0.0, qAmp: -0.18, rAmp: 1.25, sAmp: -0.40, tAmp: 0.10 });
        }
      }
      return mv;
    }

    default:
      return morphBasic(p, {});
  }
}
function schedule(kind){
  // プリ計算されたパターンを使用
  switch(kind){
    case 'sinus': return [800];
    case 'sinusArrest': {
      const normals = Array(8).fill(830);
      return [...normals, 1830];
    }
    case 'saBlock':
      return [800, 800, 1600];
    case 'avb1': return [900];
    case 'rbbb': return [800];
    case 'lbbb': return [800];
    case 'psvt': return [300];
    case 'vt': return [450];
    case 'af': 
      // 固定パターンでランダム性を模擬
      return [650, 420, 780, 520, 680, 590, 720, 480];
    case 'mobitz2': return [800];
    case 'wenckebach': return [800];
    case 'chb': return [1000];
    case 'vf': 
      // 固定パターンでVF
      return [320, 280, 350, 240, 380, 200, 420, 160];
    case 'afl': return [400];
    case 'torsades': return [500];
    case 'wpw': return [800];
    case 'earlyRepol': return [800];
    case 'stElevation': return [800];
    case 'stDepression': return [800];
    case 'hypoK': return [900];
    case 'hyperK': return [800];
    case 'qtcLong': return [900];
    case 'qtcShort': return [700];
    case 'pvc_single': {
      // 約15秒に1回の単発PVC（洞 830ms×16 ≒ 13.3s + PVC 600ms + 代償休止 1000ms）
      const normals = Array(16).fill(830);
      return [...normals, 600, 1000];
    }
    case 'pvc_frequent': return [815, 595, 1005, 790, 605, 995];
    case 'pvc_multifocal': return [840, 560, 1020, 810, 630, 960];
    case 'shortRun': {
      // 約15秒に1回ショートラン（4拍の連発）
      // 通常拍 830ms × 16拍 ≒ 13.3秒 + 連発（約2.0秒） ≒ 15.3秒
      const normals = Array(16).fill(830);
      const run = [520, 480, 480, 520];
      return [...normals, ...run];
    }
    case 'ronT': return [800];
    default: return [800];
  }
}
function updateCycle(){
  if(rhythm === 'wenckebach'){
    const base=800; const shortBy = 40 * Math.max(0, Math.min(wenckCount, 3));
    if(wenckDropThisBeat){ currentRR = base + 300 + (Math.random()*40-20);} else { currentRR = base - shortBy + (Math.random()*20-10); }
  } else if(rhythm === 'af' || rhythm === 'vf' || rrSchedule.length > 1){ currentRR = rrSchedule[nextRRIdx % rrSchedule.length]; nextRRIdx++; } else { currentRR = rrSchedule[0]; }
}
function shouldDrop(kind){ if(kind==='mobitz2'){ return mobitzDropThisBeat;} if(kind==='wenckebach'){ return wenckDropThisBeat;} if(kind==='chb') return false; return false; }
function animate(ts){
  if(!running){ requestAnimationFrame(animate); return; }

  const msPerPix = 1000 * (1/pxPerMM) / mmPerSec;
  const MAX_STEPS = 32; // cap to avoid long frames
  let dt = ts - lastTS; lastTS = ts; accMS += dt;

  // enough time accumulated?
  const steps = Math.min(MAX_STEPS, Math.floor(accMS / msPerPix));
  if(steps <= 0){ requestAnimationFrame(animate); return; }
  accMS -= steps * msPerPix;

  // Scroll once by 'steps'
  ctx.globalCompositeOperation = 'copy';
  ctx.drawImage(waveCanvas, -steps, 0);
  ctx.globalCompositeOperation = 'source-over';
  ctx.clearRect(W-steps, 0, steps, H);

  // Prepare stroke style
  const isLight = (document.documentElement.getAttribute('data-theme') === 'light');
  ctx.strokeStyle = isLight ? '#000000' : '#22d3ee';
  ctx.lineWidth = 2;
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';

  // Draw polyline for the batch
  let x = W - steps;
  let prevY = lastDrawY;
  ctx.beginPath();
  for(let i=0; i<steps; i++){
    const drop = shouldDrop(rhythm);
    const v = morphValue(rhythm, phase, drop);
    const y = baselineY + mvToPx(applyLeadScaling(v, phase));
    if(prevY == null){ prevY = y; }
    // connect from previous pixel column (x-1) to current x
    ctx.moveTo(x-1, prevY);
    ctx.lineTo(x, y);
    prevY = y;

    // advance time
    t += msPerPix; phase += msPerPix;

    // beat boundary
    if(phase >= currentRR){
      phase -= currentRR; beatCounter++;
      if(rhythm === 'ronT'){ ronCounter++; ronFlag = (ronCounter % 6) === 5; } else { ronFlag = false; }
      if(rhythm === 'wenckebach'){
        wenckCount = (wenckCount + 1) % 5;
        if(wenckCount === 4){ wenckDropThisBeat = true; currentPR = wenckPRstart; }
        else { wenckDropThisBeat = false; currentPR = wenckPRstart + wenckPRstep * wenckCount; }
      } else { wenckDropThisBeat = false; }
      if(rhythm === 'mobitz2'){
        mobitzCount = (mobitzCount + 1) % 3; mobitzDropThisBeat = (mobitzCount === 2); currentPR = 200;
      } else { mobitzDropThisBeat = false; }
      updateCycle();
    }
    x++;
  }
  ctx.stroke();
  lastDrawY = prevY;

  requestAnimationFrame(animate);
}
function resizeCanvas(){
  const dprRaw = window.devicePixelRatio || 1;
  const dpr = Math.min(dprRaw, 2);
  const rect = waveCanvas.getBoundingClientRect();
  const cssW = Math.max(600, Math.floor(rect.width));
  const cssH = Math.floor(rect.height);
  waveCanvas.width = Math.floor(cssW * dpr);
  waveCanvas.height = Math.floor(cssH * dpr);
  gridCanvas.width = Math.floor(cssW * dpr);
  gridCanvas.height = Math.floor(cssH * dpr);
  pxPerMM = basePxPerMM * dpr;
  W = waveCanvas.width; H = waveCanvas.height; baselineY = H * 0.6;
  
  // コンテキストの設定を最適化
  ctx.imageSmoothingEnabled = false;
  gtx.imageSmoothingEnabled = false;
  
  drawGrid();
  // keep continuity after resize if width unchanged; else reset lastDrawY
  lastDrawY = null;
}
let resizeT=null; window.addEventListener('resize', ()=>{ clearTimeout(resizeT); resizeT=setTimeout(resizeCanvas, 80); }); setTimeout(resizeCanvas,0);

// Quiz logic
const RHY_LIST = ['sinus','sinusArrest','saBlock','avb1','rbbb','lbbb','psvt','vt','mobitz2','wenckebach','chb','af','vf','afl','wpw','earlyRepol','stElevation','stDepression','hypoK','hyperK','qtcLong','qtcShort','torsades','pvc_single','pvc_frequent','pvc_multifocal','shortRun','ronT'];
const RHY_JA = {
  sinus: '洞調律',
  sinusArrest: '洞停止',
  saBlock: '洞ブロック',
  avb1: '房室ブロック（I度）',
  rbbb: '右脚ブロック',
  lbbb: '左脚ブロック',
  psvt: '発作性上室頻拍',
  vt: '心室頻拍',
  mobitz2: '房室ブロック（Mobitz II）',
  wenckebach: '房室ブロック（Wenckebach / Mobitz I）',
  chb: '完全房室ブロック',
  af: '心房細動',
  vf: '心室細動',
  afl: '心房粗動',
  wpw: 'WPW症候群',
  earlyRepol: '早期再分極',
  stElevation: 'ST上昇',
  stDepression: 'ST低下',
  hypoK: '低カリウム血症',
  hyperK: '高カリウム血症',
  qtcLong: 'QT延長',
  qtcShort: 'QT短縮',
  torsades: 'トルサード・ド・ポワン（多形性心室頻拍）',
  pvc_single: '期外収縮（単発）',
  pvc_frequent: '期外収縮（頻発）',
  pvc_multifocal: '多源性期外収縮',
  shortRun: '短いVTラン',
  ronT: 'R-on-T 現象'
};
function pick(){ const i=Math.floor(Math.random()*RHY_LIST.length); return RHY_LIST[i]; }
function start(){ 
  rhythm = pick(); 
  rrSchedule = schedule(rhythm); 
  nextRRIdx=0; 
  phase=0; 
  t=0; 
  beatCounter=0; 
  ronCounter=0; 
  ronFlag=false; 
  currentPR=160; 
  wenckCount=0; 
  wenckDropThisBeat=false; 
  mobitzCount=0; 
  mobitzDropThisBeat=false; 
  currentRR = rrSchedule[0] || 800;
  
  // ECGキャンバスをクリア（背景は透明のまま）
  ctx.clearRect(0, 0, W, H);
  drawGrid(); 
  lastDrawY=null; 
  if(rhythm === 'wenckebach'){ currentPR = wenckPRstart; }
  document.getElementById('ans').textContent=''; 
}

document.getElementById('reveal').addEventListener('click', ()=>{
  const ja = RHY_JA[rhythm] || rhythm;
  // PVCの定義表示（単発は60分で30未満）を補足
  let extra = '';
  if(rhythm === 'pvc_single'){
    extra = ' — 60分で30個未満（単発PVCの目安）';
  } else if(rhythm === 'pvc_frequent'){
    extra = ' — 頻発（例：二段脈など、単発の基準を超える）';
  }
  document.getElementById('ans').textContent = `解答: ${ja}（${rhythm}）${extra}`;
});

document.getElementById('next').addEventListener('click', ()=> start());

// Control event listeners
document.getElementById('speed').addEventListener('input', e => {
  mmPerSec = +e.target.value;
  document.getElementById('speedLbl').textContent = mmPerSec;
});

document.getElementById('gain').addEventListener('input', e => {
  mmPerMv = +e.target.value;
  document.getElementById('gainLbl').textContent = mmPerMv;
});

document.getElementById('leadSel').addEventListener('change', e => {
  lead = e.target.value;
});

// Initialize controls
function initControls(){
  document.getElementById('speed').value = mmPerSec;
  document.getElementById('speedLbl').textContent = mmPerSec;
  document.getElementById('gain').value = mmPerMv;
  document.getElementById('gainLbl').textContent = mmPerMv;
  document.getElementById('leadSel').value = lead;
}

// theme sync with index.html
(function initTheme(){ const saved=(()=>{ try{return localStorage.getItem('ecg.theme');}catch{return null;}})(); if(saved){ document.documentElement.setAttribute('data-theme', saved);} })();

initControls();
start();
requestAnimationFrame((ts)=>{ lastTS=ts; requestAnimationFrame(animate); });
</script>
</body>
</html>
